/**
 * Dry Run Service
 * Preview patches without applying them
 *
 * Requirements: 5.3
 * - Write patches to .render-debugger/patches/<name>.patch without applying
 * - Show what would change
 */

import { Injectable } from '@nestjs/common';
import * as fs from 'fs/promises';
import type { Patch, DryRunResult } from '../shared/types/patch.types.js';
import type { IDryRunService } from './interfaces/index.js';
import { StorageService } from '../services/storage.service.js';

@Injectable()
export class DryRunService implements IDryRunService {
  constructor(private readonly storageService: StorageService) {}

  /**
   * Preview patches without applying
   * Returns information about what would be changed
   */
  async preview(patches: Patch[]): Promise<DryRunResult> {
    const wouldModify: string[] = [];
    const validPatches: Patch[] = [];

    for (const patch of patches) {
      // Check if the file exists
      const exists = await this.fileExists(patch.filePath);

      if (exists) {
        wouldModify.push(patch.filePath);
        validPatches.push(patch);
      } else {
        console.warn(`⚠ File not found, skipping: ${patch.filePath}`);
      }
    }

    // Write patches to disk
    const patchPaths = await this.writePatchFiles(validPatches);

    return {
      patches: validPatches,
      patchPaths,
      wouldModify,
    };
  }

  /**
   * Write patches to disk without applying
   */
  async writePatchFiles(patches: Patch[]): Promise<string[]> {
    const patchPaths: string[] = [];

    for (const patch of patches) {
      const patchContent = this.formatPatchContent(patch);
      const patchPath = await this.storageService.writePatch(
        patch.id,
        patchContent,
      );
      patchPaths.push(patchPath);
    }

    return patchPaths;
  }

  /**
   * Format patch content in unified diff format
   */
  private formatPatchContent(patch: Patch): string {
    const lines: string[] = [];

    // Header
    lines.push(`# Patch generated by render-debugger`);
    lines.push(`# Suggestion ID: ${patch.suggestionId}`);
    lines.push(`# Type: ${patch.type}`);
    lines.push(`# File: ${patch.filePath}`);
    lines.push('');

    // Unified diff format
    lines.push(`--- a/${patch.filePath}`);
    lines.push(`+++ b/${patch.filePath}`);

    for (const hunk of patch.hunks) {
      const originalLines = hunk.originalContent.split('\n');
      const newLines = hunk.newContent.split('\n');

      // Hunk header
      lines.push(
        `@@ -${hunk.startLine},${originalLines.length} +${hunk.startLine},${newLines.length} @@`,
      );

      // Original lines (removed)
      for (const line of originalLines) {
        lines.push(`-${line}`);
      }

      // New lines (added)
      for (const line of newLines) {
        lines.push(`+${line}`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate a human-readable preview of changes
   */
  generatePreviewText(patches: Patch[]): string {
    const lines: string[] = [];

    lines.push('> Dry Run Preview');
    lines.push('==================');
    lines.push('');
    lines.push(`Total patches: ${patches.length}`);
    lines.push('');

    for (const patch of patches) {
      lines.push(`> ${patch.filePath}`);
      lines.push(`   Type: ${patch.type.toUpperCase()}`);
      lines.push(`   Hunks: ${patch.hunks.length}`);
      lines.push('');

      for (let i = 0; i < patch.hunks.length; i++) {
        const hunk = patch.hunks[i];
        if (!hunk) continue;

        lines.push(
          `   Hunk ${i + 1} (lines ${hunk.startLine}-${hunk.endLine}):`,
        );
        lines.push('   ─────────────────────────────────');

        // Show original
        lines.push('   Original:');
        const originalLines = hunk.originalContent.split('\n');
        for (const line of originalLines) {
          lines.push(`   - ${line}`);
        }

        // Show new
        lines.push('   New:');
        const newLines = hunk.newContent.split('\n');
        for (const line of newLines) {
          lines.push(`   + ${line}`);
        }

        lines.push('');
      }
    }

    lines.push('─────────────────────────────────────');
    lines.push('');
    lines.push('To apply these patches, run:');
    lines.push('  render-debugger fix <trace.json> --auto-apply');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Check if a file exists
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}
